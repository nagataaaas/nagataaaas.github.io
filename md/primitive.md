# 1. プリミティブ型とは
まずプリミティブが何かを説明する前に、その修飾語が掛かっている"型"とは何かを説明する必要があります。

うるせえ！プログラムが内部でどうなってるかなんて豆知識興味ねえ！という方は、[1.2](#1-2-)まで飛ばしていただいても大丈夫です。

## 1.1 型とは
プログラムはすべてコンピュータの内部で実行されていますから、当然それは電気で動いていることになります。
では、電気でどうやって普段私たちが見ているようなYoutubeの動画や音楽、このページを見ているあなたのブラウザは表現されているのでしょう。

実は、こういった情報(データ)は、電気的な信号のオンオフで表現されています。数えきれないほどの部屋がコンピュータの中にあって、それぞれの部屋が「電圧が高いバチバチの状態」か「電圧が低いショボショボの状態か」の組み合わせになってるということですね。

1つの部屋があれば、バチバチとショボショボの2種類の状態が表現できます。2つの部屋があれば、2種類×2種類で4通り、3つの部屋があれば2種類×2種類×2種類で8通り...という風に、`2の(部屋の数)乗`の表現ができるようになります。

部屋の数が少なければ表現できる数は少なく無いように見えますが、実際にはとてつもない程の表現ができます。  
部屋の数を n として、すこし表を作ってみました。

|n|2^n|
| --- | :----: |
|1|2|
|2|4|
|4|16|
|8|256|
|16|65,536|
|32|4,294,967,296|
|64|18,446,744,073,709,551,616|
|128|340,282,366,920,938,463,463,374,607,431,768,211,456|

どうでしょう？
日本の人口を1億3000万人としても、すべての人に異なる状態を割り当てるには、部屋の数がたったの30個で済んでしまうのです。

ちょっと脱線しましたが、つまるところ、コンピュータのデータというのはこういった部屋の状態の組み合わせです。
用語的には、この部屋を**ビット**という単位で数え、コンピュータは電圧の高い状態を**1**、低い状態を**0**とみなします。
たとえば、*1001*は4ビットの値で、*イチ ゼロ ゼロ イチ*という風に読みます。
もしこれを*センジュウイチ*という風に読んでしまうと、普通の10進数と見分けがつきませんので、混同しないようにしましょう。

さて、コンピュータはこのビットデータを情報として読むわけですが、これが果たして整数を表すビット列(ビットの塊)なのか、文字を表すビット列なのか、どう判断するのでしょうか？

ここで出てくるのが**型**の考えです。つまり  
"1000110は数字の70かもしれないし、文字列の'F'かもしれない。けれど、さっきプログラムの中でこの値は整数として扱うと決めたから、整数です！"  
といったように、**そのデータをどういう扱いとするか**を定めたのが型です。



## 1.2 プリミティブとは

プリミティブとは、Primitive(原始的)のことです。では、原始的な型とはなんでしょうか。

wikipediaによると

> プリミティブ型（プリミティブがた 英語: primitive data type、プリミティブデータ型）は、データ型の1分類である。理論計算機科学的に代数的データ型によって考えれば「そのデータ型の定義の中に部分として他の型を含まないような型」がプリミティブ型であるが、Javaにおいて型が「primitive types（プリミティブ型）とreference type（参照型）」に二分されることにひきずられたと思われる2分法などが信じられていることも多い。  
> この記事におけるここから先の説明は、最初に説明した理論的な分類に従ったものではなく、よく信じられているらしい「プログラミング言語によって提供されるデータ型であり基本的な要素である。対する語は複合型という。言語やその実装に依存して、プリミティブ型がコンピュータメモリ上のオブジェクトと一対一対応のときもあれば、そうでないときもある。組み込み型もしくは基本型とも呼ぶ。」という解釈に従ったものである。
>
> -- <cite>[プリミティブ型](https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AA%E3%83%9F%E3%83%86%E3%82%A3%E3%83%96%E5%9E%8B)</cite>

難しい言葉が並びましたが、要は「プログラミング言語自体が扱わせてくれる、特に基本的な型」のことです。
Pythonではこれを[組み込み型](https://docs.python.org/ja/3/library/stdtypes.html)(言語設計に直接組み込まれている型)と言います。
これには複数ありますが、特に言語の中核をなす型をピックアップしました。

まず整数を表す`int`, 浮動小数点数を表す`float`, 複素数を表す`complex`  
様々なデータをまとめて管理するもの(シーケンス)のうち、変更可能な`list`, 変更不可能な`tuple`  
文字列を表す`str`  
数学的な集合演算ができる`set`
辞書のような使い方ができる`dict` 

です。

あなたが実際にプログラムを実行して、この項目で述べているような結果になるかを確認するために、値の型を確認するための方法を先に教えておきます。  
`type(5)`のように`type()`の()の中に型を知りたいものを入力することで、その型を知ることができます。

`5`は`int`型ですから、実行結果は

```python
type(5)
# <class 'int'>
```
となります。*class*についてはのちに述べますので、今はわからなくても大丈夫です。

まずは、数値を表す上の3つから見ていきましょう。

# 2. 様々なデータ型
## 2.1 数値型
### 2.1.1 int
'integer'(整数)の略でintとなっています。
あなたのコンピュータの上の方(あるいはスマホなら...どこでしょう？)についている数字がそれです！その10個のキートップを自由自在に押すことで、あなたはint型の使い手初心者になれます。  

以下のものはすべて有効なint型のデータです

```python
1
42
763
315
+100
-100
99999999999999999999999999
```

ただし、以下のものは正しくありません

```python
01
# 0から始めることはできません

40,500,500
# 残念ですが、見やすさのためにカンマを挿入することはできません
# カンマを用いると、全く別の型と認識されます
# かわりにアンダースコア(_)を使ってください
# 正) 40_500_500
```

私たちが日頃計算を行うように、Pythonでも整数同士の計算をすることができます

|   Pythonコード   |  結果の型|   人間の記法   |
| :-------------: | :------: | :----------: |
|    a + b        |int|     a + b    |
|    a - b        |int|     a - b    |
|    a * b        |int|     a × b    |
|    a ** b        |int|     a ^ b    |
|    a / b        |float|     a ÷ b    |
|    a // b       |int|     a ÷ b の商 |
|    a % b        |int|     a ÷ b の剰余|

という風に計算できます。計算の優先順位は  
　** > ( *, /, //, % ) > ( +, - )  
となっており、同じ優先順位の間では左のものを優先します。

以下のコードと、その実行結果をその真下に記入しています。

```python
1 + 1
# 2

23 - 123
# -100

3 ** 3
# 27

3 ** 0
# 1

120 * 15
# 1800

15 / 3
# 5.0

365 / 7
# 52.142857142857146

365 // 7
# 52

365 % 7
# 1

(42 + 2) * (32 - 4)
# 1232
```

`15 / 3`と`365 / 7`の答えが小数になりましたね！これについては*float*で述べますので、しばしお待ちください...

さて、こういった計算の中にもやってはいけないことがあります。それは、ゼロで数字を割ること(ゼロ除算)です。

```python
500 / 0
# ZeroDivisionError: division by zero

0 // 0
# ZeroDivisionError: division by zero
# 0 を 0 で割るのもダメです

500 % 0
# ZeroDivisionError: integer division or modulo by zero
```

こういった、実行してみないとわからないダメなことというのもままありますので、気を付けてください。

> # int型の最大値・最小値について #
> 
> 読者の中には、すでにC言語などの他の言語に触れていて、「intの最大値は2147483647とかそんな値ではなかったか」と思っている方もいらっしゃるかと思います。
> 実際、多くの言語ではそのように実装されていますが、ことPythonはその限りではありません。
> 他の多くの言語でintの最大値が2147483647なのは、intの表現に32ビット使うからです。
> 2^32 = 4294967296 で、+と-にいい感じに値を割り振った結果、-2147483648 ~ +2147483647 を表現できるようにしています。
> それぞれの状態の1つ1つに個別の数字を割り当てているということですね。
> 
> しかし、Pythonではメモリ(コンピュータのデータを記憶する部分)の許す限り値を表現するために用いるビット数を増やすので、基本上限はありません。
> 
> こういったデータを多倍長整数と呼びますが、これのおかげでオーバーフローなどと言った問題を回避することができるのですね。やったね！

### 2.1.2 float
'floating point number'(浮動小数点数)の略でfloatとなっています。
浮動小数点数... なかなかややこしい響きですが「点がふわふわと動く数値」ですから、これはつまり、小数のある数字の「点」に着目してつけられた値ですね。

以下のものはすべて有効なfloat型のデータです

```python
1.0
1.1
1.0000000000001
-300.0
1.41421356

512.
# 512.0 と同じ
### 2.1.1 float
'floating point number'(浮動小数点数)の略でfloatとなっています。
浮動小数点数... なかなかややこしい響きですが「点がふわふわと動く数値」ですから、これはつまり、小数のある数字の「点」に着目してつけられた値ですね。

以下のものはすべて有効なfloat型のデータです

```python
1.0
1.1
1.0000000000001
-300.0
1.41421356

512.
# 512.0 と同じ

.512
# 0.512

-.512
# -0.512

3e2
# 3 * (10 ** 2) = 300

3e-2
# 3 * (10 ** -2) = 0.03
```

ただし、以下のものは正しくありません

```python
01.001
# 整数部が0ではない場合に、0から始めることはできません
# 正) 1.001

.
# 0.0 を表現するために整数部と小数部両方は省略できません
# 正) 0.0, 0., .0

5e2.3
# 指数表記の際に小数を用いることはできません
# 正) 5 * (10 ** 2.3)
```

intと同様に、四則計算などを行うことができます

|   Pythonコード   |  結果の型|   人間の記法   |
| :-------------: | :------: | :----------: |
|    a + b        |float|     a + b    |
|    a - b        |float|     a - b    |
|    a * b        |float|     a × b    |
|    a ** b        |float|     a ^ b    |
|    a / b        |float|     a ÷ b    |
|    a // b       |float|     a ÷ b の商 |
|    a % b        |float|     a ÷ b の剰余|

`1.2 - 0.2`のように答えが整数になる場合であっても、元の式のどちらか一方がfloatの時は答えもfloatになることに注意してください。

優先順位はintの時と同様です。  

```python
1.0 + 1.0
# 2.0

23.502 - 123.500
# -99.998

3.229 ** 3
# 33.666977989

3 ** 0.
# 1.0

920.2 * 15
# 13803.0

15.3 / 3
# 5.1000000000000005
# コンピュータでは、小さな値を表現しようとすると誤差が生じることがあります。
# こういった誤差を生じさせない形で計算を行うには、*decimal*や*fractions*といった機能を用いる必要があります。
# TODO: ライブラリに関する記述

365.25 / 7
# 52.17857142857143

365.0 // 7
# 52.0

365 % 7.0
# 1.0

(42.54 + 2) * (32 - 4.2)
# 1238.212
```

intのように、 0と等しい値で除算することはできません

```python
0.0 / 0.0
# ZeroDivisionError: division by zero
```


### 2.1.3 flo# 1. プリミティブ型とは
まずプリミティブが何かを説明する前に、その修飾語が掛かっている"型"とは何かを説明する必要があります。

うるせえ！プログラムが内部でどうなってるかなんて豆知識興味ねえ！という方は、[1.2](#1-2-)まで飛ばしていただいても大丈夫です。

## 1.1 型とは
プログラムはすべてコンピュータの内部で実行されていますから、当然それは電気で動いていることになります。
では、電気でどうやって普段私たちが見ているようなYoutubeの動画や音楽、このページを見ているあなたのブラウザは表現されているのでしょう。

実は、こういった情報(データ)は、電気的な信号のオンオフで表現されています。数えきれないほどの部屋がコンピュータの中にあって、それぞれの部屋が「電圧が高いバチバチの状態」か「電圧が低いショボショボの状態か」の組み合わせになってるということですね。

1つの部屋があれば、バチバチとショボショボの2種類の状態が表現できます。2つの部屋があれば、2種類×2種類で4通り、3つの部屋があれば2種類×2種類×2種類で8通り...という風に、`2の(部屋の数)乗`の表現ができるようになります。

部屋の数が少なければ表現できる数は少なく無いように見えますが、実際にはとてつもない程の表現ができます。  
部屋の数を n として、すこし表を作ってみました。

|n|2^n|
| --- | :----: |
|1|2|
|2|4|
|4|16|
|8|256|
|16|65,536|
|32|4,294,967,296|
|64|18,446,744,073,709,551,616|
|128|340,282,366,920,938,463,463,374,607,431,768,211,456|

どうでしょう？
日本の人口を1億3000万人としても、すべての人に異なる状態を割り当てるには、部屋の数がたったの30個で済んでしまうのです。

ちょっと脱線しましたが、つまるところ、コンピュータのデータというのはこういった部屋の状態の組み合わせです。
用語的には、この部屋を**ビット**という単位で数え、コンピュータは電圧の高い状態を**1**、低い状態を**0**とみなします。
たとえば、*1001*は4ビットの値で、*イチ ゼロ ゼロ イチ*という風に読みます。
もしこれを*センジュウイチ*という風に読んでしまうと、普通の10進数と見分けがつきませんので、混同しないようにしましょう。

さて、コンピュータはこのビットデータを情報として読むわけですが、これが果たして整数を表すビット列(ビットの塊)なのか、文字を表すビット列なのか、どう判断するのでしょうか？

ここで出てくるのが**型**の考えです。つまり  
"1000110は数字の70かもしれないし、文字列の'F'かもしれない。けれど、さっきプログラムの中でこの値は整数として扱うと決めたから、整数です！"  
といったように、**そのデータをどういう扱いとするか**を定めたのが型です。



## 1.2 プリミティブとは

プリミティブとは、Primitive(原始的)のことです。では、原始的な型とはなんでしょうか。

wikipediaによると

> プリミティブ型（プリミティブがた 英語: primitive data type、プリミティブデータ型）は、データ型の1分類である。理論計算機科学的に代数的データ型によって考えれば「そのデータ型の定義の中に部分として他の型を含まないような型」がプリミティブ型であるが、Javaにおいて型が「primitive types（プリミティブ型）とreference type（参照型）」に二分されることにひきずられたと思われる2分法などが信じられていることも多い。  
> この記事におけるここから先の説明は、最初に説明した理論的な分類に従ったものではなく、よく信じられているらしい「プログラミング言語によって提供されるデータ型であり基本的な要素である。対する語は複合型という。言語やその実装に依存して、プリミティブ型がコンピュータメモリ上のオブジェクトと一対一対応のときもあれば、そうでないときもある。組み込み型もしくは基本型とも呼ぶ。」という解釈に従ったものである。
>
> -- <cite>[プリミティブ型](https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AA%E3%83%9F%E3%83%86%E3%82%A3%E3%83%96%E5%9E%8B)</cite>

難しい言葉が並びましたが、要は「プログラミング言語自体が扱わせてくれる、特に基本的な型」のことです。
Pythonではこれを[組み込み型](https://docs.python.org/ja/3/library/stdtypes.html)(言語設計に直接組み込まれている型)と言います。
これには複数ありますが、特に言語の中核をなす型をピックアップしました。

まず整数を表す`int`, 浮動小数点数を表す`float`, 複素数を表す`complex`  
様々なデータをまとめて管理するもの(シーケンス)のうち、変更可能な`list`, 変更不可能な`tuple`  
文字列を表す`str`  
数学的な集合演算ができる`set`
辞書のような使い方ができる`dict` 

です。

あなたが実際にプログラムを実行して、この項目で述べているような結果になるかを確認するために、値の型を確認するための方法を先に教えておきます。  
`type(5)`のように`type()`の()の中に型を知りたいものを入力することで、その型を知ることができます。

`5`は`int`型ですから、実行結果は

```python
type(5)
# <class 'int'>
```
となります。*class*についてはのちに述べますので、今はわからなくても大丈夫です。

まずは、数値を表す上の3つから見ていきましょう。

# 2. 様々なデータ型
## 2.1 数値型
### 2.1.1 int
'integer'(整数)の略でintとなっています。
あなたのコンピュータの上の方(あるいはスマホなら...どこでしょう？)についている数字がそれです！その10個のキートップを自由自在に押すことで、あなたはint型の使い手初心者になれます。  

以下のものはすべて有効なint型のデータです

```python
1
42
763
315
+100
-100
99999999999999999999999999
```

ただし、以下のものは正しくありません

```python
01
# 0から始めることはできません

40,500,500
# 残念ですが、見やすさのためにカンマを挿入することはできません
# カンマを用いると、全く別の型と認識されます
# かわりにアンダースコア(_)を使ってください
# 正) 40_500_500
```

私たちが日頃計算を行うように、Pythonでも整数同士の計算をすることができます

|   Pythonコード   |  結果の型|   人間の記法   |
| :-------------: | :------: | :----------: |
|    a + b        |int|     a + b    |
|    a - b        |int|     a - b    |
|    a * b        |int|     a × b    |
|    a ** b        |int|     a ^ b    |
|    a / b        |float|     a ÷ b    |
|    a // b       |int|     a ÷ b の商 |
|    a % b        |int|     a ÷ b の剰余|

という風に計算できます。計算の優先順位は  
　** > ( *, /, //, % ) > ( +, - )  
となっており、同じ優先順位の間では左のものを優先します。

以下のコードと、その実行結果をその真下に記入しています。

```python
1 + 1
# 2

23 - 123
# -100

3 ** 3
# 27

3 ** 0
# 1

120 * 15
# 1800

15 / 3
# 5.0

365 / 7
# 52.142857142857146

365 // 7
# 52

365 % 7
# 1

(42 + 2) * (32 - 4)
# 1232
```

`15 / 3`と`365 / 7`の答えが小数になりましたね！これについては*float*で述べますので、しばしお待ちください...

さて、こういった計算の中にもやってはいけないことがあります。それは、ゼロで数字を割ること(ゼロ除算)です。

```python
500 / 0
# ZeroDivisionError: division by zero

0 // 0
# ZeroDivisionError: division by zero
# 0 を 0 で割るのもダメです

500 % 0
# ZeroDivisionError: integer division or modulo by zero
```

こういった、実行してみないとわからないダメなことというのもままありますので、気を付けてください。

> # int型の最大値・最小値について #
> 
> 読者の中には、すでにC言語などの他の言語に触れていて、「intの最大値は2147483647とかそんな値ではなかったか」と思っている方もいらっしゃるかと思います。
> 実際、多くの言語ではそのように実装されていますが、ことPythonはその限りではありません。
> 他の多くの言語でintの最大値が2147483647なのは、intの表現に32ビット使うからです。
> 2^32 = 4294967296 で、+と-にいい感じに値を割り振った結果、-2147483648 ~ +2147483647 を表現できるようにしています。
> それぞれの状態の1つ1つに個別の数字を割り当てているということですね。
> 
> しかし、Pythonではメモリ(コンピュータのデータを記憶する部分)の許す限り値を表現するために用いるビット数を増やすので、基本上限はありません。
> 
> こういったデータを多倍長整数と呼びますが、これのおかげでオーバーフローなどと言った問題を回避することができるのですね。やったね！


### 2.1.2 float
'floating point number'(浮動小数点数)の略でfloatとなっています。
浮動小数点数... なかなかややこしい響きですが「点がふわふわと動く数値」ですから、これはつまり、小数のある数字の「点」に着目してつけられた値ですね。

以下のものはすべて有効なfloat型のデータです

```python
1.0
1.1
1.0000000000001
-300.0
1.41421356

512.
# 512.0 と同じ

.512
# 0.512

-.512
# -0.512

3e2
# 3 * (10 ** 2) = 300

3e-2
# 3 * (10 ** -2) = 0.03
```

ただし、以下のものは正しくありません

```python
01.001
# 整数部が0ではない場合に、0から始めることはできません
# 正) 1.001

.
# 0.0 を表現するために整数部と小数部両方は省略できません
# 正) 0.0, 0., .0

5e2.3
# 指数表記の際に小数を用いることはできません
# 正) 5 * (10 ** 2.3)
```

intと同様に、四則計算などを行うことができます

|   Pythonコード   |  結果の型|   人間の記法   |
| :-------------: | :------: | :----------: |
|    a + b        |float|     a + b    |
|    a - b        |float|     a - b    |
|    a * b        |float|     a × b    |
|    a ** b        |float|     a ^ b    |
|    a / b        |float|     a ÷ b    |
|    a // b       |float|     a ÷ b の商 |
|    a % b        |float|     a ÷ b の剰余|

`1.2 - 0.2`のように答えが整数になる場合であっても、元の式のどちらか一方がfloatの時は答えもfloatになることに注意してください。

優先順位はintの時と同様です。  

```python
1.0 + 1.0
# 2.0

23.502 - 123.500
# -99.998

3.229 ** 3
# 33.666977989

3 ** 0.
# 1.0

920.2 * 15
# 13803.0

15.3 / 3
# 5.1000000000000005
# コンピュータでは、小さな値を表現しようとすると誤差が生じることがあります。
# こういった誤差を生じさせない形で計算を行うには、*decimal*や*fractions*といった機能を用いる必要があります。
# TODO: ライブラリに関する記述

365.25 / 7
# 52.17857142857143

365.0 // 7
# 52.0

365 % 7.0
# 1.0

(42.54 + 2) * (32 - 4.2)
# 1238.212
```

intのように、 0と等しい値で除算することはできません

```python
0.0 / 0.0
# ZeroDivisionError: float division by zero
```


### 2.1.3 complex
'complex number'(複素数)の略でcomplexとなっています。つまり、虚数に関する数値ですね。  
正直、筆者はこの値を用いている業務的なプログラムを1度も見たことがありません。数学や工学の分野で用いそうな方以外は「そんなのもあったなぁ」程度で構わないと思います。

一般的に複素数を表記しようとすると

> 12 + i3

のように表記すると思いますが、Pythonでは

- iではなくjを用いる
- 数値の後ろにjをつける

というルールがあります。

以下のものはすべて有効なcomplex型のデータです

```python
1j
.0j
1.1j
5 + 3j
3.4 + 1j
1 + 0j
```

ただし、以下のものは正しくありません

```python
.j
# 0.0jのために、0を両方省略することはできません
# なお、 0.0jと入力した場合でも、0jと解釈されます
# 正) 0.0j, 0j

j
# 1jの1を省略することはできません
# 正) 1j
```

一部の四則計算などを行うことができます

|   Pythonコード   |  結果の型|   人間の記法   |
| :-------------: | :------: | :----------: |
|    a + b        |complex|     a + b    |
|    a - b        |complex|     a - b    |
|    a * b        |complex|     a × b    |
|    a ** b        |complex|     a ^ b    |
|    a / b        |complex|     a ÷ b    |

計算に用いるどちらか一方でもcomplex型である場合、`//`と`%`を用いることは出来ないので注意してください。

```python

```